# Yλοποίηση Βάσεων Δεδομένων

Εκπόνηση από:

- Γιώργος Ζορπίδης - 1115202000055
- Γιάννης Κώτσιας  - 1115202000113

Για όλες τις συναρτήσεις χρησιμοποιήθηκε η κλήση μέσω της `TC` (Tested Call) για πιο εύκολο debugging και για να μην ξαναγράφουμε πολύ κώδικα.

## Εργασία 1

### Heap File

Για το heap file η εικόνα είναι παρόμοια της εικόνας που δίνεται 

![](https://i.gyazo.com/92d9ad76855f452ab6821c9897323d23.png)
 
Δημιουργούμε το αρχείο φτιάχνοντας το πρώτο μπλοκ που κρατάει τα μεταδεδομένα και αρχικοποιούμε τα επόμενα και τελευταία μπλοκ με -1. Κατά την εισαγωγή ελέγχουμε: Αν υπάρχει μόνο ένα μπλοκ μέσα, θα πρέπει να δημιουργήσουμε το επόμενο, να βάλουμε την εγγραφή και έπειτα να συνδέσουμε το πρώτο μπλοκ ώστε να δείχνει στο επόμενο και στο τελευταίο μπλοκ στο νέο allocated block. Αλλιώς, πρέπει να δούμε το αν το τελευταίο μπλοκ είναι γεμάτο ή όχι. Αν δεν είναι γεμάτο, τότε απλά βάζουμε την εγγραφή στην ελεύθερη θέση, αλλιώς: Φτιάχνουμε ένα νέο μπλοκ και πρέπει αφού βάλουμε την εγγραφή να βάλουμε στο προ τελευταίο (πλέον, παλιό τελευταίο) μπλοκ να δείχνει ως "επόμενο του" το καινούριο μας μπλοκ, και το πρώτο μπλοκ να δείχνει ως νέο τελευταίο μπλοκ στο νέο καινούριο μας μπλοκ. 

Για να βάλουμε το `HP_info_block` στην τελευταία θέση πρέπει να πάρουμε το αρχικό δείκτη των δεδομένων να πάμε δεξιά όσο το μέγεθος του μπλοκ και μετά πίσω, όσο είναι το μέγεθος του `HP_info_block`.

Η getAllEntries όταν βρει το match στο id λήγει την περαιτέρω αναζήτηση. Η λειτουργία της είναι σχετικά απλή αφού σειριακά πηγαίνει από το κάθε μπλοκ στο επόμενό του, ελέγχοντας τις εγγραφές ενός του για κάποιο match.

#### Structure
Η δομή HP_info κρατάει μεταδεδομένα που σχετίζονται με το αρχείο σωρού που αναπαριστά το HP. Η δομή αποτελείται από τα πεδία:
1) fileDesc: ο αριθμός του ανοικτού αρχείου σωρού
2) headerPosition: η θέση του header στο αρχείο σωρού
3) recordsPerBlock: ο αριθμός των εγγραφών που χωράει ένα block
4) isHeapFile/isHash: ένα flag που δείχνει αν το αρχείο σωρού είναι ένα αρχείο σωρού ή ένα αρχείο hash.

Η δομή HP_BlockInfo κρατάει μεταδεδομένα που σχετίζονται με ένα block του αρχείου σωρού. Η δομή αποτελείται από τα πεδία:
1) currentRecords: ο τρέχων αριθμός των εγγραφών που υπάρχουν στο block
2) recordsCount: η χωρητικότητα του block σε εγγραφές η οποία είναι ( sizeof(char) * BF_BLOCK_SIZE - sizeof(HP_block_info) ) / sizeof(Record)
3) nextBlock: η θέση του επόμενου block στο αρχείο σωρού

#### Functions
Τα παρακάτω functions υλοποιούνται στο αρχείο hp_file.c:
1) HP_CreateFile: Δημιουργεί και αρχικοποιεί ένα νέο αρχείο σωρού με όνομα filename. Η συνάρτηση TC()  χρησιμοποιείται σε όλο το εύρος των εργασιών για error handling. Στο τέλος γίνονται τα κατάλληλα BF_Block_SetDirty και BF_Block_Destroy. Η συνάρτηση επιστρέφει 0 σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
2) HP_OpenFile: Ανοίγει το αρχείο σωρού με όνομα filename. Σε περίπτωση αποτυχίας επιστρέφει NULL.
3) HP_CloseFile: Κλείνει το αρχείο σωρού που αναπαριστά το HP_info που δέχεται ως παράμετρο. Επιστρέφει 0 σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
4) HP_InsertEntry: Εισάγει μια εγγραφή στο αρχείο σωρού που αναπαριστά το HP_info που δέχεται ως παράμετρο. Επιστρέφει το blockID σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
5) HP_GetAllEntries: Επιστρέφει όλες τις εγγραφές του αρχείου σωρού που αναπαριστά το HP_info που δέχεται ως παράμετρο με ID == Value και εκτυπώνει τα περιεχόμενα της. Επιστρέφει τα blocks που διαβάστηκαν σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.

### Static hashing

Για το Static hashing αρχείο: Στο πρώτο μπλοκ θα πρέπει να κρατήσουμε μερικά δεδομένα και μετά το ίδιο το hashTable. Επειδή γνωρίζουμε ότι το hashTable είναι πρακτικά ένας πίνακας δεικτών προς μπλοκ, και πρέπει να χωράει μέσα στο πρώτο μπλοκ, τότε ορίζουμε ένα μέγιστο μέγεθος κουβάδων στο 30. Ωστόσο ως δείκτες εμείς ορίζουμε πρακτικά έναν ακέραιο αριθμό, το αναγνωριστικό blockId κάθε μπλοκ. 

![](https://i.gyazo.com/f398951649e2d3a0d562f866c422164b.png)

Κατά την δημιουργία του αρχείου, αρχικοποιούμε τους κουβάδες ώστε να δείχνουν στα αρχικά μπλοκ. Έτσι κάνουμε το block allocation των κουβάδων proactively, αντί να κοιτάμε στο insertion αν η θέση είναι NULL (δηλαδή -1) και να κάνουμε allocate το μπλοκ εκείνη την στιγμή.

Κατά την εισαγωγή, hashάρουμε το ID με βάσει την hash function (εμείς ορίσαμε να είναι απλά το ID % (αριθμό κουβάδων). Αυτό μας δείχνει το σε ποιον "κουβά" θα μπεί η εγγραφή. Κατά την εισαγωγή ,επίσης,ακολουθήσαμε την τεχνική που περιγράφηκε κατά την παρουσίαση/φροντιστήριο της εργασίας, κατά την οποία: ΑΝ το μπλοκ στο οποίο δείχνει ο κουβάς είναι γεμάτος, δημιουργούμε ένα νέο μπλοκ, βάζουμε την εγγραφή, και έπειτα: α) Ορίζουμε ο κουβάς να δείχνει στο **νέο μπλοκ**, και β) το νέο μπλοκ να δείχνει στον παλίο μπλοκ το οποίο είναι γεμάτο ως επόμενό του. Επομένως η επόμενη εισαγωγή η οποία θα χασάρει στον "κουβά" αυτόν, θα μπει στο μπλοκ με το 1 μόλις στοιχείο.

Π.χ. Έστω ότι έχουμε 5 κουβάδες. Τότε κατά την αρχικοποίηση ο κουβάς για τα στοιχεία 0 θα δείχνει στο μπλοκ 1, ο κουβάς για τα στοιχεία [1] θα δείχνει στο μπλοκ 2, κλπ. Έστω ότι έχουμε εξαντλήσει το μέγεθος του κουβά [0], χωρίς να έχουμε κάνουμε allocate άλλου μπλοκ. Η επόμενη εισαγωγή στον κουβά [0] θα δημιουργήσει το μπλοκ 6, και θα θέσει τον κουβά [0] να δείχνει στο 6, ενώ το 6 θα δείχνει στο παλιό μπλοκ, δηλαδή στο 1. 

Η ιδέα αυτή φαίνεται και παρακάτω:

![](https://i.gyazo.com/6c1ba0186b47cc166bcc6a15e1921dfc.png)

Η GetAllEntries θα κοιτάξει λοιπόν όλο το chain των buckets (και overflow buckets αν υπάρχουν) για το id το οποίο δίνεται, και έπειτα σειριακά όλα τα στοιχεία μέχρι να τα βρει.

#### Structure
Η δομή είναι ίδια με την δομή του αρχείου σωρού με την διαφορά ότι έχει προσθεθεί το hashTable.

#### Functions
Τα παρακάτω functions υλοποιούνται στο αρχείο ht_table.c:
1) HT_CreateFile: Δημιουργεί και αρχικοποιεί ένα νέο αρχείο κατακερματισμού με όνομα filename. Το μέγεθος του hashTable είναι ( sizeof(char) * BF_BLOCK_SIZE - sizeof(HT_info) ). Επίσης γίνεται η δημιουργία και η αρχικοποίηση των buckets. Στο τέλος γίνονται τα κατάλληλα BF_Block_SetDirty και BF_Block_Destroy. Η συνάρτηση επιστρέφει 0 σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
2) HT_OpenFile: Ανοίγει το αρχείο κατακερματισμού με όνομα filename. Σε περίπτωση αποτυχίας επιστρέφει NULL.
3) HT_CloseFile: Κλείνει το αρχείο κατακερματισμού που αναπαριστά το HT_info που δέχεται ως παράμετρο. Επιστρέφει 0 σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
4) HT_InsertEntry: Εισάγει μια εγγραφή στο αρχείο κατακερματισμού που αναπαριστά το HT_info που δέχεται ως παράμετρο. Επιστρέφει το blockID σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.
5) HT_GetAllEntries: Επιστρέφει όλες τις εγγραφές του αρχείου κατακερματισμού που αναπαριστά το HT_info που δέχεται ως παράμετρο με ID == Value και εκτυπώνει τα περιεχόμενα της. Επιστρέφει τα blocks που διαβάστηκαν σε περίπτωση επιτυχίας και -1 σε περίπτωση αποτυχίας.


## Εργασία 2

Τα αρχεία sht_table.h, sht_table.c, sht_main.c πρέπει να αποθηκευτούν στους φακέλους include, src, και examples αντίστοιχα, ενώ το Makefile αντικαθιστά το παλιό Makefile.
Για την διαγραφή των αρχείων που δημιουργούνται χρειάζεται η κλήση της make clear.


Για την εργασία 2, δημιουργούμε το Secondary Index το οποίο βασίζεται σε μέγαλο βαθμό στην ίδια λογική του Hash Table. Η λογική διαφέρει στο ότι: Εμείς δεν αποθηκεύουμε στο δευτερεύον ευρετήριο μια ολόκληρη εγγραφή πλέον, αλλά μια διάδα του ονόματος και του μπλοκ στο οποίο βρίσκεται μια εγγραφή στο πρωτεύον ευρετήριο (η οποία επιστρέφεται από το insert της HT). 

![](https://i.gyazo.com/3868961d3a5bd15555aed10128968d68.png)


Ένα σημαντικό edge case το οποίο αναφέρθηκε στο eClass είναι ότι, έστω ότι βάζουμε δύο εγγραφές ("Μαριάννα", 1, ...), και ("Μαριάννα", 11, ...) στο πρωτεύον ευρετήριο, τα οποία όμως μπαίνουν στο ίδιο μπλοκ του, π.χ. το 1. Εμείς στο δευτερεύον ευρετήριο θα βάλουμε <"Μαριάννα", 2> και <"Μαριάννα",2>, εκεί που χασάρει το όνομα "Μαριάννα". Αμα τα εισαγαγάμε κανονικά, τότε στην GetAllEntries για το όνομα "Μαριάννα" θα βλέπαμε αρχικά το 1ο <"Μαριάννα",2> και θα πηγαίναμε στο 2ο μπλοκ του primary index, στο οποίο όπως περνάγαμε θα βρίσκαμε τις 2 εγγραφές. Μετά όμως θα βλέπαμε το 2ο <"Μαριάννα",2> και θα ξαναπηγαίναμε στο 2ο μπλοκ του primary index στο οποιο θα ξαναβρίσκαμε τις εγγραφές. Κάτι τέτοιο όμως δεν το θέλουμε. Αν γράφαμε C++ θα μπορούσαμε να κάναμε χρήση ενός std::map/std::set το οποίο να κράταγε τα visited block. Επειδή δεν ξέραμε αν κάτι τέτοιο θα επιτρεπόταν, αποφασίσαμε προτού να κάνουμε την εισαγωγή να ελέγχουμε αν υπάρχει διπλότυπο στον κουβά. Κάτι τέτοιο δεν είναι ιδιαίτερα αποδοτικό ωστόσο, αφού μπορεί να χρειαστεί να κατεβαίνουμε ένα μακρύ chain.

Η getAllEntries είναι ιδιαίτερα περίπλοκη στον κώδικά της, αφού θα πρέπει να κατεβαίνουμε το chain στο secondary index, να ελέγχουμε το αν το δωθέν όνομα είναι στην διάδα secIndexEntry και αν είναι να λαμβάνουμε το μπλοκ στο primary index, και να περνάμε από όλο το μπλοκ αυτό στο πρωτεύον ευρετήριο ώστε να βρούμε ένα match ονόματος.